{
  "id": "1",
  "stream": "computer-science-information-technology",
  "packet": "2023",
  "year": "2023",
  "type": "MCQ",
  "key": "(C)\n \nSol.\n \n:\n \nMethod 1 \n:\n \n \nThe given DFA generate strings like:  \n \n{1,10,110,100,1011,1000....}\n\uf053\uf03d\n*\n(0 11)\n\uf02b\nSo, start with 1 to reach final state from where wave two choices os\n*\n1(0 11)\n\uf02b\n.\nHence R.E. is\nChecking options:  \n \n(a) \nDosen\u2019t generate 10 \n \n(b) \nDosen\u2019t generate any os it starts with 0. \n \n(d)  Dosen\u2019t generate 10.  \n \nHence, the correct option is (C). \n \n:\n \nMethod 2 \n:\n \n \nGiven DFA shown below\n0\n1\n1\nS\nP\nQ\n1\nr\n0\n0\n0, 1\n\nSince state \nr\n is the dead state. So it can be removed.\n0\n1\n1\nS\nP\nQ\n\n1\nRequired Regular Expression\n1(0 11)*\n\uf03d\n\uf02b",
  "question_text": "Question 1 \n \nConsider the following statements regarding the front-end and back-end of a compiler. S1: The front-end \nincludes phases that are independent of the target hardware.  \n \nS2: The back-end includes phases that are specific to the target hardware.  \n \nS3: The back-end includes phases that are specific to the programming language used in the source code.  \n \nIdentify the CORRECT option \n \n     \n[Complier Design, Lexical Analysis] \n \n(A) Only S1 is TRUE. \n(B) Only S1 and S2 are TRUE \n \n(C) S1, S2, and S3 are all TRUE \n(D) Only S1 and S3 are TRUE \nAns.\n \n(B)\n \nSol.\n\nGATE 2023 \n [Forenoon Session]\nComputer Science Engineering\nPAGE\n8\n\nLexical Analysis\nFront end\n(High level programming\nSyntax Analysis\nlanguage)\nSemmantic Analysis\nIntermediate Code Generations\nCode Optimization\nBack end\n(Hardware)\nCode Generation\nS1 : The front end or analysis phase consists of lexical, syntax and semantic analysis.  \nIt takes source language and produces intermediate code representation. It is independent of target \nhardware. So, S1 is true. \nS2 : The bock-end or synthesis phase consists of code optimization and target code generation phases \nwhich takes intermediate code and generates target code as output. It is dependent on target hardware. S2 \nis true.  \nS3 : Back-end phase is independent of source program as its task is to convert the intermediate code to \ntarget code. S3 is false.  \n \nHence, the correct option is (B). \nQuestion 2 \n \nWhich one of the following sequences when stored in an array at locations A[1],...,A[10] forms a max-\nheap ?  \n \n  \n[Data Structure, Tree] \n \n(A) 23, 17, 10, 6, 13, 14, 1, 5, 7, 12 \n(B) 23, 17, 14, 7, 13, 10, 1, 5, 6, 12 \n \n(C) 23, 17, 14, 6, 13, 10, 1, 5, 7, 15 \n(D) 23, 14, 17, 1, 10, 13, 16, 12, 7, 5 \nAns.\n \n(B)\n \nSol.\n \nHere, we have to check all options for finding which one satisfies property of max-heap. i.e. \n \n(i) \nHeap is a complete binary Tree \n \n(ii) Parent element is always greater than child element value.  \n \nUpon checking only\n23\n17\n14\n7\n13\n10\n1\n5\n6\n12\n\n\nGATE 2023 \n [Forenoon Session]\nComputer Science Engineering\nPAGE\n9\n\nHence, the correct option is (B). \nQuestion 3 \n \nLet SLLdel be a function that deletes a node in a singly-linked list given a pointer to the node and a pointer \nto the head of the list. Similarly, let DLLdel be another function that deletes a node in a doubly-linked list \ngiven a pointer to the node and a pointer to the head of the list.  \n \nLet \nn\n denote the number of nodes in each of the linked lists. Which one of the following choices is TRUE \nabout the worst-case time complexity of SLLdel and DLLdel ?\n[Data Structure, Linked List] \n \n(A) SLLdel is \nO\n(1) and DLLdel is \nO\n(\nn\n) \n(B) Both SLLdel and DLLdel are \nO\n(log(n)) \n \n(C) Both SLLdel and DLLdel are \nO\n(1) \n(D) SLLdel is \nO\n(n) and DLLdel is \nO\n(1) \nAns.\n \n(D)\n \nSol.\n \nGiven a single linked list SLL:\nA\nB\nC\nX\nY\nZ\nHere, were given head pointer and ptr pointer of the node to be deleted (Here y) We have to traverse from \nhead node till node before the one pointed by ptr (here X) which take \n( )\nO n\n time in worst case.\nHead\nPtr\nGiven a doubly linked list DLL:\nZ\nX\nA\nB\nX\nY\nX\nSimply we can do it as:  \n \nptr \n\uf0ae\nprev \n\uf0ae\nnext = ptr \n\uf0ae\n next  \n \nptr \n\uf0ae\nnext \n\uf0ae\nprev= ptr \n\uf0ae\nprev \n \ndelete (ptr) \n \nsince it can be performed in \n(1)\nO\ntime:\nHead\nPtr\nHence, the correct option is (D).\n \nQuestion 4 \n \nConsider the Deterministic Finite-state Automaton (DFA) A shown below. The DFA runs on the alphabet \n{0, 1}, and has the set of states {s, p, q, r}, with s being the start state and p being the only final state\n0\n1\ns\np\n1\nq\n1\n0\nr\n0\n1,0\n\n\nGATE 2023 \n [Forenoon Session]\nComputer Science Engineering\nPAGE\n10\n\nWhich one of the following regular expressions correctly describes the language accepted by A?\n[Theory of Computation & Finite Automata]\n \n \n(A) \n1(0*11)*\n \n(B) \n0(0 1)*\n\uf02b\n(C) \n1(0 11)*\n\uf02b\n \n(D) \n1(110*)*",
  "answer_text": "(C)\n \nSol.\n \n:\n \nMethod 1 \n:\n \n \nThe given DFA generate strings like:  \n \n{1,10,110,100,1011,1000....}\n\uf053\uf03d\n*\n(0 11)\n\uf02b\nSo, start with 1 to reach final state from where wave two choices os\n*\n1(0 11)\n\uf02b\n.\nHence R.E. is\nChecking options:  \n \n(a) \nDosen\u2019t generate 10 \n \n(b) \nDosen\u2019t generate any os it starts with 0. \n \n(d)  Dosen\u2019t generate 10.  \n \nHence, the correct option is (C). \n \n:\n \nMethod 2 \n:\n \n \nGiven DFA shown below\n0\n1\n1\nS\nP\nQ\n1\nr\n0\n0\n0, 1\n\nSince state \nr\n is the dead state. So it can be removed.\n0\n1\n1\nS\nP\nQ\n\n1\nRequired Regular Expression\n1(0 11)*\n\uf03d\n\uf02b",
  "explanation_text": ""
}