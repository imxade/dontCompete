{
  "id": "43",
  "stream": "computer-science-information-technology",
  "packet": "2021-N",
  "year": "2021",
  "type": "MCQ",
  "key": "(A)",
  "question_text": "Question 43. \n \n \n \n  \n \n \n \n \nMCQ (2M)\nQuestion ID : 8232513130\nConsider the following ANSI C code segment:\nz = x + 3 + y->f1 + y->f2;\nfor (i = 0; i < 200; i = i + 2){ \n if (z > i) { \np = p + x + 3; \nq = q + y->f1;\n} else {\np = p + y- >f 2; \nq = q + x + 3;\n}\n}\nAssume that the variable y points to a struct (allocated on the heap) containing two fields fl and f2. \nand the local variables x. y. z, p. q. and i are allotted registers. Common sub-expression elimination \n(CSE) optimization is applied on the code. The number of addition and dereference operations (of the \nform y->f 1 or y->f2 ) in the optimized code, respectively, are:\n(A)\n \n303 and 2\n\nPAGE\n30\n\n(B)\n \n 203 and 2 \n(C)\n \n 403 and 102 \n(D)\n \n303 and 102",
  "answer_text": "(A)",
  "explanation_text": "Sol. \nIn compiler theory, common subexpression elimination is a compiler optimization that searches for \ninstances for identical expressions (i.e, they all evaluate to the same value), and analyzes whether it is \nworthwhile replacing them with a single variable holding the computed value.\nFor example: Consider the following block of code\na = x+y+z;\nr = p+q;\nb = x+y+r;\nThe code after common subexpression elimination.\nt=x+y;\na=t+z;\nr=p+q;\nb=t+r;\nIn the given code z = x + 3 + y -> f1 + y -> f2;\nfor (i = 0; i < 200; i = i+2) {\nif (z > i)\n{\np = p + x + 3;\nq = q + y -> f1;\n}\nelse\n{\np = p + y -> f2;\nq = q + x + 3;\n}\n}\nX+3 is common subexpression, also y -> f1 & y -> f2 is found in first line itself so they are also like \ncommon subexpression. Hence the code after common subexpression\nt1=x+3;\nt2=y -> f1;\nt3= y -> f2;\nz = t1 + t2 + t3;\n\nPAGE\n31\n\nfor (i = 0; i < 200; i = i+2){\nif (z > i) {\np = p + t1;\nq = q + t2;\n}\nelse{\np = p + t3;\nq = q + t1;\n}\n}\nHence two dereference operations (of the form y->f1 or y->f2) in the optimized code. The number of \nadditions in the optimized code are: Loop will execute for 100 times and in loop one addition (i+2) \nSo 100 additions. Inside loop we have two additions (either in if block or in else block) so 200 \nadditions inside loop.\nHence 300 additions in loop (loop body as well as inside)\nFirst 2 lines contains 3 additions\nt1=x+3;\nz = t1 + t2 + t3;\nHence total 303 additions. So 303 and 2 are the answer."
}